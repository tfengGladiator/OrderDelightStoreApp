@page "/menus"
@page "/menus/{MenuId}"
@using MenuItem = OrderDelightLibrary.Shared.Models.MenuItem
@inject DialogService DialogService
@inject StoreAppService StoreAppService
@inject IJSRuntime JSRuntime
    @if (selectedMenu == null)
    {
        <div class="alert alert-danger" role="alert">
            No active menus available.
        </div>
    }
    else
    {
        <div class="menu-container">
            <ul style="list-style-type: none; padding: 0; display: flex; background-color: #f7f6f6; margin-bottom: 0px;">
                @foreach (var menu in MenuList)
                {
                    <li style="@($"cursor: pointer; padding: 10px 20px 15px 20px; border-bottom: {(menu.id == selectedMenu.id ? "3px solid orange" : "none")}; text-align: center; margin:0 10px 0 10px;")"
                        @onclick="@(() => HandleClick(menu.id))">
                        <div style="font-size: 20px; margin: 5px 0;">@menu.Name</div>
                    </li>
                }
            </ul>

            <div class="nav-container">
                <!-- Category List -->
                <div class="categories-container">
                    <ul class="category-list">
                        @foreach (var cat in Categories)
                        {
                            <li class="@(cat == selectedCategory ? "category-item selected" : "category-item")"
                                @onclick="@(() => SelectCategory(cat))">
                                @cat.Name
                            </li>
                        }
                    </ul>
                </div>

                <!-- Food Items -->
                <div class="food-list-container">
                    <ul class="food-list">
                        @foreach (var menuItem in GetFoodItems(selectedCategory))
                        {
                            var foodItem = FoodItems.FirstOrDefault(f => f.id == menuItem.FoodItemId);
                            if (foodItem == null) continue;

                            <li class="food-item">
                                <a href="JavaScript:void(0)" @onclick="@(async () => await ViewFoodOptions(foodItem))">
                                    <img src="@ResolveImagePath(foodItem)" onerror="imageError(this)" class="food-image">
                                    <span class="food-price">@ResolveFoodItemPrice(foodItem)</span>
                                    <div class="food-info">
                                        <span class="food-name">@ResolveFoodItemName(foodItem)</span>
                                    </div>
                                </a>
                            </li>
                        }
                    </ul>
                </div>
            </div>
        </div>
    }


<style>
    /* Container for menu and categories for better alignment */
    .nav-container {
        display: flex;
        flex-direction: row; /* Horizontal layout */
        width: 100%;
    }

    .categories-container {
        width: 200px; /* Adjust width as needed */
        margin: 20px 0 0 10px;
        flex-grow: 1;
    }

    .category-list {
        list-style-type: none;
        padding: 0;
        margin: 0;
        background-color: white;
        display: block; /* Stack items vertically */
    }

    .category-item {
        padding: 15px 10px; /* Reduced padding on the right */
        cursor: pointer;
        text-align: left;
        overflow: hidden; /* Prevents content from overflowing */
        text-overflow: ellipsis; /* Adds an ellipsis to indicate hidden text */
        display: -webkit-box;
        -webkit-line-clamp: 2; /* Limit text to two lines */
        -webkit-box-orient: vertical;
        height: 50px; /* Adjust height based on your design needs */
        border-bottom: 3px solid transparent; /* Maintains layout consistency */
    }


        .category-item.selected {
            background-color: #FFD2A0; /* Light orange background color */
            color: black; /* Ensures text is readable against light background */
        }

    .food-list-container {
        height: 60vh; /* Set to a fixed height or based on viewport (vh) */
        overflow-y: scroll; /* Only vertical scrolling */
        flex-grow: 4;
        width: 80%;
        padding-left: 20px;
        padding-top: 10px;
    }

    /* Previous styles ... */
    .food-list {
        list-style-type: none;
        padding: 0;
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-start; /* Align items to the start */
        gap: 15px; /* Reduced gap between the flex items */
    }

    .food-item {
        position: relative;
        flex: 0 1 auto; /* Allows the box to not grow but shrink if needed, without setting a base size */
        display: flex;
        justify-content: center; /* Centers child elements horizontally */
        align-items: flex-end; /* Align children to the bottom */
        width: 180px; /* Set a reduced fixed width for the food item */
        margin: 10px; /* Adds space around each food item */
        margin-bottom: 0; /* Adjust or remove margin-bottom if needed */
        padding-bottom: 0; /* Adjust or remove padding-bottom if needed */
    }

    .food-image {
        position: relative;
        width: 180px; /* Adjusted fixed width */
        height: 180px; /* Adjusted fixed height */
        object-fit: cover; /* Adjusts the image to cover the area without stretching */
        border: 1px solid #cccccc; /* Very thin light grey border */
    }


    .food-info {
        position: absolute;
        bottom: 0; /* Align to the bottom of the food-item */
        left: 0;
        width: 100%; /* Ensure the info covers the width of the food-item */
        height: 65px;
        background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent background */
        color: white;
        padding: 10px;
        box-sizing: border-box; /* Ensures padding does not add to the width */
        text-align: center; /* Center-align the text */
        min-height: 50px; /* Adjust as needed to set a fixed height for the name section */
        display: flex;
        flex-direction: column;
        justify-content: center; /* This will center the content vertically */
        align-items: center; /* Align horizontal centering */
    }


    .food-price {
        position: absolute; /* Absolute positioning relative to the food-item */
        top: 10px; /* Space from the top edge of the food-item */
        right: 0; /* Align to the right side of the image */
        background: rgba(146, 211, 110, 0.9); /* Semi-transparent green background for better readability */
        padding: 2px 10px 2px 20px; /* Adjusted padding for a better fit: less padding on the right and slightly less on the left */
        border-radius: 30px 0 0 30px; /* Adjusted radius for a balanced look */
        z-index: 2; /* Ensures the price is above the image */
        font-size: 14px; /* Suitable font size for visibility */
    }



    .food-name {
        margin-top: auto; /* This pushes the name to the bottom */
        margin-bottom: 0px; /* Space from the bottom edge of the .food-info */
        display: flex; /* Use flexbox to center content */
        align-items: center; /* Align vertically */
        justify-content: center; /* Align horizontally */
        text-align: center; /* Center text for readability */
        height: 65px; /* Fixed height to ensure that single and multiline text is centered */
        font-size: 14px;
    }
</style>

@code {

    [Parameter] public string MenuId { get; set; } = "";
    private Category selectedCategory; // Initially no selection
    private List<Category> Categories = new List<Category>();
    private Menu? selectedMenu; // Initially no selection
    ImageSize largeFoodItemImageSize;
    List<Menu> MenuList = new List<Menu>();
    List<FoodItem>? FoodItems;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("setupScrollHandling", DotNetObjectReference.Create(this));
        }
    }

    protected override async Task OnInitializedAsync()
    {
        if (StoreAppService.CurrentStore == null)  
            await StoreAppService.LoadStoreAsync("101-1");
        if(StoreAppService.FoodItems == null)
            FoodItems = await StoreAppService.GetFoodItemsAsync();
        
        var storeLocalTime = CommonUtilities.ConvertToLocalTime(DateTime.UtcNow, StoreAppService.CurrentStore.TimeZoneId);
        var currentTime = storeLocalTime.TimeOfDay;
        var currentDay = storeLocalTime.DayOfWeek;
        if(StoreAppService.Menus == null)
            MenuList = await StoreAppService.GetFilteredMenusAsync();

        MenuList = MenuList
            .Where(m => IsMenuActive(m, currentDay, currentTime))
            .OrderBy(m => GetEarliestStartTime(m, currentDay))
            .Distinct().ToList();
        if (!MenuList.Any())
            return; // No active menus

        if (!string.IsNullOrWhiteSpace(MenuId) && MenuList.Any(m => m.id.ToLower() == MenuId.ToLower()))
            selectedMenu = MenuList.FirstOrDefault(m => m.id.ToLower() == MenuId.ToLower());
        else
            selectedMenu = MenuList.FirstOrDefault();

        LoadFoodItems();
    }

    private void LoadFoodItems()
    {
        if (selectedMenu == null) return;
        Categories = selectedMenu.Categories.Where(c => c.FoodItems.Any()).ToList();
        if (Categories.Any())
            selectedCategory = Categories.FirstOrDefault();

        FoodItems = selectedCategory?.FoodItems
            .Select(fi => StoreAppService.FoodItems.FirstOrDefault(f => f.id == fi.FoodItemId))
            .Where(f => f != null)
            .ToList();
    }

    private bool IsMenuActive(Menu menu, DayOfWeek currentDay, TimeSpan currentTime)
    {
        Console.WriteLine($"Checking menu: {menu.Name}"); // Add a log here

        if (menu.IsDeleted || !menu.IsEnabled)
            return false; // Not active if deleted or not enabled

        var matchingDayHour = menu.DayHours.FirstOrDefault(dh => dh.DayOfWeek == currentDay);
        if (matchingDayHour != null)
        {
            Console.WriteLine($"\tDayHour found for {currentDay}.");
            if (matchingDayHour.IsClosed)
                return false; // Not active if closed

            if (matchingDayHour.TimeRanges.Any(tr => IsTimeRangeValid(tr, currentTime)))
                return true; // Active at this point
        }
        return false;
    }



    private bool IsTimeRangeValid(TimeRange timeRange, TimeSpan currentTime)
    {
        // Attempt to parse the StartTime and EndTime into DateTime objects to handle AM/PM
        if (DateTime.TryParse(timeRange.StartTime, out var startDateTime) &&
            DateTime.TryParse(timeRange.EndTime, out var endDateTime))
        {
            // Extract the TimeOfDay part, which is a TimeSpan
            var startTime = startDateTime.TimeOfDay;
            var endTime = endDateTime.TimeOfDay;

            // Now compare with currentTime
            return currentTime >= startTime && currentTime <= endTime;
        }
        else
        {
            Console.WriteLine($"Error parsing time range: Start: {timeRange.StartTime}, End: {timeRange.EndTime}");
            return false;
        }
    }


    private TimeSpan GetEarliestStartTime(Menu menu, DayOfWeek currentDay)
    {
        return menu.DayHours
            .Where(dh => dh.DayOfWeek == currentDay)
            .SelectMany(dh => dh.TimeRanges)
            .Select(tr =>
            {
                if (DateTime.TryParse(tr.StartTime, out var dateTime))
                {
                    return dateTime.TimeOfDay;
                }
                else
                {
                    Console.WriteLine($"Error parsing start time for menu: {menu.Name}, Start: {tr.StartTime}");
                    return TimeSpan.MaxValue; // Fallback to max value to ensure this doesn't affect the min calculation negatively.
                }
            })
            .Min();
    }


    string[] ResolveToday(Menu menu)
    {
        if (StoreAppService.CurrentStore == null) return new[] { "-" };

        Console.WriteLine("StoreAppService.CurrentStore.TimeZoneId: " + StoreAppService.CurrentStore.TimeZoneId);
        var today = CommonUtilities.ConvertToLocalTime(DateTime.UtcNow, StoreAppService.CurrentStore.TimeZoneId).DayOfWeek;
        var dayHours = menu.DayHours.FirstOrDefault(d => d.DayOfWeek == today);
        if (dayHours == null) return new[] { "-" };

        return dayHours.ToString().Split("|");
    }
    // private List<MenuItem> MenuItems = new List<MenuItem>()
    // {
    //     new MenuItem { Name = "Breakfast", StartTime = "7:00 AM", EndTime = "10:00 AM" },
    //     new MenuItem { Name = "Lunch", StartTime = "12:00 PM", EndTime = "2:00 PM" },
    //     new MenuItem { Name = "Dinner", StartTime = "6:00 PM", EndTime = "9:00 PM" }
    // };

    private void HandleClick(string menuId)
    {
        selectedMenu = MenuList.FirstOrDefault(m => m.id.ToLower() == menuId.ToLower()); 
        LoadFoodItems();
    }

    private List<MenuItem> GetFoodItems(Category category) // Replace with your logic to fetch food items
    {
        if (category == null) return new List<MenuItem>();

        return category.FoodItems;
    }

    async Task ViewFoodOptions(FoodItem? foodItem)
    {
        var dic = new Dictionary<string, object>();
        dic.Add("FoodItem", foodItem);
        dic.Add("OnChange", EventCallback.Factory.Create(this, RefreshPage));
        var dialogOptions = new DialogOptions() { CssClass = "custom-dialog" };
        await DialogService.OpenAsync<FoodOptions>("Food Options", dic, dialogOptions);
    }

    void RefreshPage()
    {
        StateHasChanged();
    }


    private string ResolveImagePath(FoodItem foodItem)
    {
        return StoreAppService.GetFoodItemImageUrl(foodItem);
    }

    private string ResolveFoodItemName(FoodItem foodItem)
    {
        return StoreAppService.ResolveLanguage(foodItem.Names);
    }

    private string ResolveFoodItemPrice(FoodItem foodItem)
    {
        return "$25.5";
    }

    private void SelectCategory(Category category)
    {
        selectedCategory = category;
    }

    [JSInvokable]
    public async Task SwitchToNextCategory()
    {
    // Logic to switch to the next category
        int currentIndex = Categories.IndexOf(selectedCategory);
        if (currentIndex < Categories.Count - 1)
            selectedCategory = Categories[currentIndex + 1];

        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task SwitchToPreviousCategory()
    {
    // Logic to switch to the previous category
        int currentIndex = Categories.IndexOf(selectedCategory);
        if (currentIndex > 0)
            selectedCategory = Categories[currentIndex - 1];

        await InvokeAsync(StateHasChanged);
    }

    public async ValueTask DisposeAsync()
    {
        await JSRuntime.InvokeVoidAsync("removeScrollHandling");
    }
}